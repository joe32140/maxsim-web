<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MaxSim Web Benchmark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 15px;
            text-align: center;
            position: relative;
        }

        .github-link {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0.9;
        }

        .github-link:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .github-link svg {
            width: 28px;
            height: 28px;
        }

        @media (min-width: 768px) {
            .github-link {
                top: 25px;
                right: 25px;
            }

            .github-link svg {
                width: 32px;
                height: 32px;
            }
        }

        .github-link .label {
            font-size: 14px;
            font-weight: 600;
            display: none;
        }

        @media (min-width: 768px) {
            .github-link .label {
                display: block;
            }
        }

        @media (min-width: 768px) {
            header {
                padding: 30px;
            }
        }

        header h1 {
            font-size: 1.8em;
            margin-bottom: 10px;
            line-height: 1.2;
        }

        header p {
            font-size: 1em;
            opacity: 0.9;
        }

        @media (min-width: 768px) {
            header h1 {
                font-size: 2.5em;
            }
            
            header p {
                font-size: 1.2em;
            }
        }

        .content {
            padding: 15px;
        }

        @media (min-width: 768px) {
            .content {
                padding: 30px;
            }
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #90caf9;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            border: 1px solid #81c784;
        }

        .status.warning {
            background: #fff3e0;
            color: #f57c00;
            border: 1px solid #ffb74d;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
            border: 1px solid #e57373;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                margin-bottom: 30px;
            }
        }

        @media (min-width: 1024px) {
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        select, input[type="number"] {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px; /* Prevents zoom on iOS */
            transition: border-color 0.3s;
            min-height: 44px; /* Touch-friendly minimum */
        }

        @media (min-width: 768px) {
            select, input[type="number"] {
                padding: 10px;
                font-size: 14px;
            }
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (min-width: 480px) {
            .buttons {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
        }

        @media (min-width: 768px) {
            .buttons {
                display: flex;
                margin-bottom: 30px;
            }
        }

        button {
            flex: 1;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 44px; /* Touch-friendly minimum */
        }

        @media (min-width: 768px) {
            button {
                padding: 15px 30px;
                font-size: 16px;
            }
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        button.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: #f5f5f5;
            color: #333;
        }

        button.secondary:hover:not(:disabled) {
            background: #e0e0e0;
        }

        .progress {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }

        @media (min-width: 768px) {
            .progress {
                padding: 20px;
                margin-bottom: 20px;
            }
        }

        .progress.active {
            display: block;
        }

        .progress-bar {
            background: #e0e0e0;
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .progress-text {
            text-align: center;
            color: #666;
        }

        .results {
            margin-top: 30px;
        }

        .results h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        @media (min-width: 768px) {
            .results h2 {
                margin-bottom: 20px;
                font-size: 1.8em;
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
        }

        th, td {
            padding: 8px 6px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
            font-size: 12px;
        }

        @media (min-width: 768px) {
            table {
                margin-bottom: 30px;
                font-size: 14px;
            }
            
            th, td {
                padding: 12px 15px;
                font-size: 14px;
            }
        }

        /* Mobile table scrolling */
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        @media (max-width: 767px) {
            .table-container {
                margin: 0 -15px;
                padding: 0 15px;
            }
        }

        td:nth-child(5), th:nth-child(5) {
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tr:hover {
            background: #fafafa;
        }

        .speedup {
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }

        .speedup.fast {
            background: #e8f5e9;
            color: #388e3c;
        }

        .speedup.slow {
            background: #ffebee;
            color: #d32f2f;
        }

        .chart {
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        @media (min-width: 768px) {
            .chart {
                margin-top: 30px;
                padding: 20px;
            }
        }

        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .bar-chart {
                gap: 15px;
            }
        }

        .bar-row {
            display: flex;
            align-items: center;
            gap: 10px;
            min-height: 40px;
        }

        @media (min-width: 768px) {
            .bar-row {
                gap: 15px;
                min-height: 50px;
            }
        }

        .bar-label {
            min-width: 120px;
            font-weight: 600;
            color: #333;
            font-size: 12px;
        }

        @media (min-width: 768px) {
            .bar-label {
                min-width: 180px;
                font-size: 14px;
            }
        }

        .bar-container {
            flex: 1;
            background: #e0e0e0;
            border-radius: 6px;
            height: 32px;
            position: relative;
            overflow: hidden;
            border: 1px solid #ccc;
        }

        @media (min-width: 768px) {
            .bar-container {
                height: 40px;
            }
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 8px;
            color: white;
            font-weight: 600;
            font-size: 11px;
            transition: width 1s ease-out;
            min-width: 50px;
            white-space: nowrap;
        }

        @media (min-width: 768px) {
            .bar-fill {
                padding: 0 10px;
                font-size: 13px;
                min-width: 60px;
            }
        }

        .log {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            -webkit-overflow-scrolling: touch;
        }

        @media (min-width: 768px) {
            .log {
                padding: 20px;
                margin-top: 20px;
                max-height: 300px;
                font-size: 12px;
            }
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .timestamp {
            color: #999;
            margin-right: 10px;
        }

        /* Preloaded benchmark styles */
        .preload-info {
            background: #e8f5e9;
            padding: 10px;
            border-left: 4px solid #4caf50;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 13px;
        }

        .preload-info strong {
            color: #2e7d32;
        }

        tr.preloaded {
            background: #f1f8f4 !important;
            border-left: 3px solid #4caf50;
        }

        tr.preloaded:hover {
            background: #e8f5e9 !important;
        }

        .preload-badge {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }

        .preload-metric {
            display: inline-block;
            background: #fff3e0;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px 4px;
            font-size: 12px;
            border: 1px solid #ffb74d;
        }

        .preload-metric strong {
            color: #f57c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="https://github.com/joe32140/maxsim-web" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">
                <svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                <span class="label">GitHub</span>
            </a>
            <h1>üöÄ MaxSim Web Benchmark</h1>
            <p>JavaScript/WASM Performance Testing</p>
        </header>

        <div class="content">
            <div id="status" class="status info">
                Initializing benchmark suite...
            </div>

            <div class="status warning">
                <strong>üìä Performance Note:</strong> JS Optimized shows 1.25x speedup in Node.js but minimal improvement in browsers due to different JIT optimization strategies. For best browser performance, use WASM+SIMD.
            </div>

            <div class="status info">
                <strong>üéØ Variable-Length Testing:</strong> The variable-length scenarios test real-world conditions where documents have different lengths. This showcases the adaptive batching optimizations in WASM for realistic workloads.
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="scenario">Scenario</label>
                    <select id="scenario">
                        <optgroup label="Uniform Length">
                            <option value="tiny">Tiny (10 docs √ó 64 tokens)</option>
                            <option value="small">Small (10 docs √ó 256 tokens)</option>
                            <option value="medium">Medium (100 docs √ó 256 tokens)</option>
                            <option value="large">Large (100 docs √ó 512 tokens)</option>
                            <option value="realistic">Realistic (100 docs √ó 2000 tokens)</option>
                            <option value="xl">XL (1000 docs √ó 512 tokens)</option>
                        </optgroup>
                        <optgroup label="Variable Length (Real World)">
                            <option value="variable-small">Variable Small (100 docs, 128-256 tokens)</option>
                            <option value="variable-medium" selected>Variable Medium (1000 docs, 128-512 tokens) ‚≠ê</option>
                            <option value="variable-large">Variable Large (1000 docs, 200-400 tokens)</option>
                        </optgroup>
                    </select>
                </div>

                <div class="control-group">
                    <label for="warmup">Warmup Iterations</label>
                    <input type="number" id="warmup" value="1" min="0" max="100">
                </div>

                <div class="control-group">
                    <label for="iterations">Benchmark Iterations</label>
                    <input type="number" id="iterations" value="1" min="1" max="1000">
                </div>

                <div class="control-group">
                    <label for="embeddingType">Embedding Type</label>
                    <select id="embeddingType">
                        <option value="random">Random (Standard)</option>
                        <option value="realistic">Realistic (ColBERT-like)</option>
                        <option value="compare">Compare Both</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="embeddingDim">Embedding Dimension</label>
                    <select id="embeddingDim">
                        <option value="128">128 dimensions</option>
                        <option value="256" selected>256 dimensions</option>
                        <option value="512">512 dimensions</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button id="runBtn" class="primary">Run Benchmark</button>
                <button id="runAllBtn" class="secondary">Run All Scenarios</button>
                <button id="realismBtn" class="secondary">Test Realism Impact</button>
                <button id="exportBtn" class="secondary" disabled>Export Results</button>
            </div>

            <div id="progress" class="progress">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill">0%</div>
                </div>
                <div id="progressText" class="progress-text">Preparing...</div>
            </div>

            <div id="results" class="results" style="display: none;">
                <h2>Benchmark Results</h2>
                <div id="resultsContent"></div>
            </div>

            <div id="log" class="log" style="display: none;"></div>
        </div>
    </div>

    <script type="module">
        import { MaxSimWasm } from './maxsim-wasm.js';
        import { MaxSimBaseline } from '../src/js/maxsim-baseline.js';
        import { MaxSimOptimized } from '../src/js/maxsim-optimized.js';
        import { scenarios, generateFixtures, calculateOperations } from './fixtures.js';
        import { generateRealisticDataset, compareEmbeddingTypes } from './realistic-embeddings.js';

        // Enable debug logging to measure pure WASM time
        window.__MAXSIM_DEBUG = true;

        // UI Elements
        const statusEl = document.getElementById('status');
        const runBtn = document.getElementById('runBtn');
        const runAllBtn = document.getElementById('runAllBtn');
        const realismBtn = document.getElementById('realismBtn');
        const exportBtn = document.getElementById('exportBtn');
        const progressEl = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultsEl = document.getElementById('results');
        const resultsContent = document.getElementById('resultsContent');
        const logEl = document.getElementById('log');

        let benchmarkResults = [];
        let isRunning = false;

        // Logging
        function log(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="timestamp">${timestamp}</span>${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            logEl.style.display = 'block';
            console.log(message);
        }

        // Helper function to initialize WASM with better error handling
        async function initializeWasm(scenario) {
            if (!await MaxSimWasm.isSupported()) {
                return null;
            }

            try {
                const wasmImpl = new MaxSimWasm();
                await wasmImpl.init();
                log('‚úÖ WASM+SIMD ready');
                return wasmImpl;
            } catch (err) {
                log(`‚ö†Ô∏è WASM+SIMD failed: ${err.message}`);
                return null;
            }
        }

        function setStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function setProgress(percent, text) {
            progressFill.style.width = `${percent}%`;
            progressFill.textContent = `${percent}%`;
            progressText.textContent = text;
        }

        // Statistical helpers
        function mean(arr) {
            return arr.reduce((sum, v) => sum + v, 0) / arr.length;
        }

        function median(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0
                ? (sorted[mid - 1] + sorted[mid]) / 2
                : sorted[mid];
        }

        function percentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const idx = Math.ceil((p / 100) * sorted.length) - 1;
            return sorted[Math.max(0, idx)];
        }

        function stdDev(arr) {
            const avg = mean(arr);
            const squareDiffs = arr.map(v => Math.pow(v - avg, 2));
            return Math.sqrt(mean(squareDiffs));
        }

        // Benchmark implementation
        async function benchmarkImplementation(name, impl, fixtures, options) {
            const { warmup = 10, iterations = 100 } = options;
            const { query, documents } = fixtures;

            log(`Benchmarking ${name}...`);

            // Warmup
            setProgress(0, `${name}: Warming up...`);
            for (let i = 0; i < warmup; i++) {
                // Use hyper-optimized method for WASM
                if (impl.maxsimBatchHyperOptimized) {
                    impl.maxsimBatchHyperOptimized(query, documents);
                } else if (impl.maxsimBatchZeroAlloc) {
                    impl.maxsimBatchZeroAlloc(query, documents);
                } else {
                    impl.maxsimBatch(query, documents);
                }
                if (i % 5 === 0) {
                    setProgress(Math.floor((i / warmup) * 30), `${name}: Warmup ${i}/${warmup}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Benchmark
            const times = [];
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                // Use hyper-optimized method for WASM
                const scores = impl.maxsimBatchHyperOptimized ? 
                    impl.maxsimBatchHyperOptimized(query, documents) :
                    impl.maxsimBatchZeroAlloc ? 
                    impl.maxsimBatchZeroAlloc(query, documents) : 
                    impl.maxsimBatch(query, documents);
                const end = performance.now();
                times.push(end - start);

                if (i % 10 === 0) {
                    const progress = 30 + Math.floor((i / iterations) * 70);
                    setProgress(progress, `${name}: Iteration ${i}/${iterations}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            setProgress(100, `${name}: Complete!`);

            const totalTime = times.reduce((sum, t) => sum + t, 0);
            const throughput = (documents.length * iterations) / totalTime * 1000;

            return {
                name,
                mean: mean(times),
                median: median(times),
                min: Math.min(...times),
                max: Math.max(...times),
                stdDev: stdDev(times),
                p95: percentile(times, 95),
                p99: percentile(times, 99),
                throughput,
                iterations
            };
        }

        // Benchmark preloaded implementation
        async function benchmarkPreloaded(name, impl, fixtures, options) {
            const { warmup = 10, iterations = 100 } = options;
            const { query, documents } = fixtures;

            log(`Benchmarking ${name} (PRELOADED)...`);

            // Step 1: Load documents (one-time cost) - use FLAT API like fast-plaid!
            setProgress(0, `${name}: Flattening documents...`);
            const flattenStart = performance.now();

            // Pre-flatten documents to avoid expensive conversion in loadDocuments
            const embeddingDim = documents[0][0].length;
            const docTokenCounts = new Uint32Array(documents.length);
            let totalTokens = 0;
            for (let i = 0; i < documents.length; i++) {
                docTokenCounts[i] = documents[i].length;
                totalTokens += documents[i].length;
            }

            const allEmbeddings = new Float32Array(totalTokens * embeddingDim);
            let offset = 0;
            for (let i = 0; i < documents.length; i++) {
                const docEmb = documents[i];
                for (let j = 0; j < docEmb.length; j++) {
                    const token = docEmb[j];
                    for (let d = 0; d < embeddingDim; d++) {
                        allEmbeddings[offset + d] = token[d];
                    }
                    offset += embeddingDim;
                }
            }

            const flattenTime = performance.now() - flattenStart;
            log(`üìä Flattened ${documents.length} docs in ${flattenTime.toFixed(2)}ms`);

            // Now load using FLAT API (fast!)
            setProgress(5, `${name}: Loading documents...`);
            const loadStart = performance.now();
            await impl.loadDocuments(allEmbeddings, docTokenCounts, embeddingDim);
            const loadTime = performance.now() - loadStart;
            const numDocs = impl.numDocumentsLoaded();
            log(`üì¶ Loaded ${numDocs} documents in ${loadTime.toFixed(2)}ms`);

            // Step 2: Pre-flatten query for zero-overhead searches
            setProgress(10, `${name}: Flattening query...`);
            const queryTokens = query.length;
            const queryFlat = new Float32Array(queryTokens * embeddingDim);
            let idx = 0;
            for (let token of query) {
                for (let val of token) {
                    queryFlat[idx++] = val;
                }
            }

            // Step 3: Warmup with preloaded search (using flat API directly!)
            setProgress(15, `${name}: Warming up preloaded search...`);
            for (let i = 0; i < warmup; i++) {
                impl.wasmInstance.search_preloaded(queryFlat, queryTokens);
                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Step 4: Benchmark preloaded search (flat API = zero conversion overhead!)
            setProgress(20, `${name}: Running benchmark...`);
            const times = [];
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                const scores = impl.wasmInstance.search_preloaded(queryFlat, queryTokens);
                const end = performance.now();
                const iterTime = end - start;
                times.push(iterTime);

                // Log first iteration for detailed timing
                if (i === 0 && window.__MAXSIM_DEBUG) {
                    console.log(`[PRELOADED JS] First iteration pure WASM time: ${iterTime.toFixed(2)}ms`);
                    console.log(`[PRELOADED JS] Query shape: ${queryTokens} tokens √ó ${embeddingDim} dim`);
                    console.log(`[PRELOADED JS] Num docs loaded: ${impl.numDocumentsLoaded()}`);
                }

                if (i % 10 === 0) {
                    const progress = 20 + Math.floor((i / iterations) * 80);
                    setProgress(progress, `${name}: Iteration ${i}/${iterations}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            setProgress(100, `${name}: Complete!`);

            const totalTime = times.reduce((sum, t) => sum + t, 0);
            const throughput = (documents.length * iterations) / totalTime * 1000;

            return {
                name,
                mean: mean(times),
                median: median(times),
                min: Math.min(...times),
                max: Math.max(...times),
                stdDev: stdDev(times),
                p95: percentile(times, 95),
                p99: percentile(times, 99),
                throughput,
                iterations,
                loadTime: flattenTime + loadTime,  // Total one-time cost (flatten + load)
                flattenTime,  // Track separately for analysis
                wasmLoadTime: loadTime,  // Pure WASM load time
                isPreloaded: true  // NEW: flag for display
            };
        }

        // Run single scenario
        async function runBenchmark(scenarioName, options = {}) {
            const scenario = scenarios[scenarioName];
            if (!scenario) {
                throw new Error(`Unknown scenario: ${scenarioName}`);
            }

            // Generate fixtures based on embedding type and dimension
            const embeddingType = document.getElementById('embeddingType').value;
            const embeddingDim = document.getElementById('embeddingDim').value;
            
            // Use selected embedding dimension
            const effectiveScenario = { ...scenario };
            effectiveScenario.dim = parseInt(embeddingDim);

            log(`Starting benchmark: ${effectiveScenario.name}`);
            log(`Query: ${effectiveScenario.queryTokens} tokens √ó ${effectiveScenario.dim} dims`);
            if (effectiveScenario.variableLength) {
                log(`Docs: ${effectiveScenario.numDocs} docs √ó ${effectiveScenario.minDocTokens}-${effectiveScenario.docTokens} tokens (VARIABLE)`);
            } else {
                log(`Docs: ${effectiveScenario.numDocs} docs √ó ${effectiveScenario.docTokens} tokens`);
            }
            log(`üîß Using embedding dimension: ${effectiveScenario.dim}`);

            setStatus(`Running ${effectiveScenario.name}...`, 'info');
            progressEl.classList.add('active');
            
            let fixtures;
            if (embeddingType === 'realistic') {
                log('üß¨ Generating realistic ColBERT-like embeddings...');
                fixtures = generateRealisticDataset(effectiveScenario);
            } else {
                log('üé≤ Generating random embeddings...');
                fixtures = generateFixtures(effectiveScenario);
            }

            const implementations = [
                { name: 'JS Baseline', impl: new MaxSimBaseline() },
                { name: 'JS Optimized', impl: new MaxSimOptimized() }
            ];

            // Try to add WASM with improved error handling
            setStatus('üîÑ Loading WASM module...', 'info');
            const wasmImpl = await initializeWasm(scenario);
            
            if (wasmImpl) {
                implementations.push({ name: 'WASM+SIMD', impl: wasmImpl });
                // Add preloaded benchmark (NEW v0.5.0!)
                implementations.push({
                    name: 'WASM+SIMD (Preloaded)',
                    impl: wasmImpl,
                    usePreloaded: true
                });
                setStatus(`Running ${scenario.name}...`, 'info');
            } else {
                log('‚ö†Ô∏è WASM+SIMD unavailable - JS only');
                setStatus(`Running ${scenario.name} (JS only)...`, 'warning');
            }

            const results = [];

            for (let i = 0; i < implementations.length; i++) {
                const { name, impl, usePreloaded } = implementations[i];

                // Use preloaded benchmark if flagged
                const result = usePreloaded
                    ? await benchmarkPreloaded(name, impl, fixtures, options)
                    : await benchmarkImplementation(name, impl, fixtures, options);

                results.push(result);

                // Small delay to keep UI responsive
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            progressEl.classList.remove('active');

            // Display results
            displayResults(effectiveScenario, results);

            return { scenario: effectiveScenario, results };
        }

        // Display results
        function displayResults(scenario, results) {
            const baseline = results[0]; // JS Baseline

            let variableLengthBadge = scenario.variableLength ?
                '<span style="background: #4caf50; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; margin-left: 10px;">üìä VARIABLE LENGTH</span>' : '';

            let html = `
                <h3>${scenario.name} - ${scenario.description} ${variableLengthBadge}</h3>
                <p><strong>Total Operations:</strong> ${calculateOperations(scenario).toLocaleString()}</p>
                ${scenario.variableLength ? `<p><strong>Document Lengths:</strong> ${scenario.minDocTokens}-${scenario.maxDocTokens || scenario.docTokens} tokens</p>` : ''}

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Implementation</th>
                                <th>Mean (ms)</th>
                                <th>Median (ms)</th>
                                <th>P95 (ms)</th>
                                <th>Throughput (docs/s)</th>
                                <th>Speedup</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const result of results) {
                const speedup = baseline.mean / result.mean;
                const speedupClass = speedup >= 1.0 ? 'fast' : 'slow';
                const arrow = speedup >= 1.0 ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';

                // Add preload badge if this is a preloaded result
                const badge = result.isPreloaded ? '<span class="preload-badge">‚ö° Preloaded</span>' : '';
                const rowClass = result.isPreloaded ? ' class="preloaded"' : '';

                html += `
                    <tr${rowClass}>
                        <td><strong>${result.name}${badge}</strong></td>
                        <td>${result.mean.toFixed(2)}</td>
                        <td>${result.median.toFixed(2)}</td>
                        <td>${result.p95.toFixed(2)}</td>
                        <td>${result.throughput.toLocaleString('en-US', {maximumFractionDigits: 0})}</td>
                        <td><span class="speedup ${speedupClass}">${speedup.toFixed(2)}x ${arrow}</span></td>
                    </tr>
                `;

                // Add preload metrics row if applicable
                if (result.isPreloaded) {
                    const amortizedCost = (result.loadTime + result.mean * 100) / 100;
                    html += `
                        <tr${rowClass}>
                            <td colspan="6" style="padding: 8px 15px;">
                                <div class="preload-info">
                                    <span class="preload-metric"><strong>Load Time (one-time):</strong> ${result.loadTime.toFixed(2)} ms</span>
                                    <span class="preload-metric"><strong>Amortized (100 searches):</strong> ${amortizedCost.toFixed(2)} ms/search</span>
                                    <span class="preload-metric"><strong>Speedup vs Non-Preloaded:</strong> ${(results[results.length - 2].mean / result.mean).toFixed(2)}x</span>
                                </div>
                            </td>
                        </tr>
                    `;
                }
            }

            html += `
                    </tbody>
                </table>
                </div>

                <div class="chart">
                    <h4>Throughput Comparison</h4>
                    <div class="bar-chart">
            `;

            const maxThroughput = Math.max(...results.map(r => r.throughput));

            for (const result of results) {
                const width = (result.throughput / maxThroughput) * 100;
                html += `
                    <div class="bar-row">
                        <div class="bar-label">${result.name}</div>
                        <div class="bar-container">
                            <div class="bar-fill" style="width: ${width}%">
                                ${result.throughput.toFixed(0)} docs/s
                            </div>
                        </div>
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;

            resultsContent.innerHTML = html;
            resultsEl.style.display = 'block';

            log(`‚úÖ Benchmark complete! Best: ${results[results.length - 1].name} at ${results[results.length - 1].mean.toFixed(2)}ms`);
            setStatus(`Benchmark complete! Check results below.`, 'success');
            exportBtn.disabled = false;
        }

        // Run all scenarios
        async function runAllBenchmarks() {
            isRunning = true;
            runBtn.disabled = true;
            runAllBtn.disabled = true;
            benchmarkResults = [];

            const scenarioNames = Object.keys(scenarios);

            for (const name of scenarioNames) {
                const result = await runBenchmark(name, {
                    warmup: parseInt(document.getElementById('warmup').value),
                    iterations: parseInt(document.getElementById('iterations').value)
                });
                benchmarkResults.push(result);
            }

            isRunning = false;
            runBtn.disabled = false;
            runAllBtn.disabled = false;

            setStatus('All benchmarks complete!', 'success');
        }

        // Test realism impact
        async function testRealismImpact() {
            isRunning = true;
            runBtn.disabled = true;
            runAllBtn.disabled = true;
            realismBtn.disabled = true;

            const scenarioName = document.getElementById('scenario').value;
            const scenario = scenarios[scenarioName];
            const embeddingDim = document.getElementById('embeddingDim').value;
            
            // Use selected embedding dimension
            const effectiveScenario = { ...scenario };
            effectiveScenario.dim = parseInt(embeddingDim);
            log(`üîß Using embedding dimension: ${effectiveScenario.dim}`);
            
            setStatus('Testing realism impact...', 'info');
            progressEl.classList.add('active');
            
            log('üß™ Starting realism impact test...');
            log(`Scenario: ${effectiveScenario.name} (${effectiveScenario.dim}D)`);

            // Get best available implementation
            setProgress(10, 'Initializing implementation for realism test...');
            let implementation = await initializeWasm(effectiveScenario);
            
            if (implementation) {
                log('‚úÖ Using WASM+SIMD for realism test');
            } else {
                implementation = new MaxSimOptimized();
                log('‚ÑπÔ∏è Using JS Optimized for realism test');
            }

            setProgress(25, 'Generating random embeddings...');
            
            // Generate random embeddings
            const randomFixtures = generateFixtures(effectiveScenario);
            
            setProgress(50, 'Generating realistic embeddings...');
            
            // Generate realistic embeddings
            const realisticFixtures = generateRealisticDataset(effectiveScenario);
            
            setProgress(75, 'Running performance comparison...');

            const iterations = 30; // Fewer iterations for comparison
            
            // Benchmark random embeddings
            const randomTimes = [];
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                const scores = implementation.maxsimBatchHyperOptimized ? 
                    implementation.maxsimBatchHyperOptimized(randomFixtures.query, randomFixtures.documents) :
                    implementation.maxsimBatch(randomFixtures.query, randomFixtures.documents);
                randomTimes.push(performance.now() - start);
            }

            // Benchmark realistic embeddings
            const realisticTimes = [];
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                const scores = implementation.maxsimBatchHyperOptimized ? 
                    implementation.maxsimBatchHyperOptimized(realisticFixtures.query, realisticFixtures.documents) :
                    implementation.maxsimBatch(realisticFixtures.query, realisticFixtures.documents);
                realisticTimes.push(performance.now() - start);
            }

            setProgress(100, 'Analyzing results...');

            const randomMean = mean(randomTimes);
            const realisticMean = mean(realisticTimes);
            const difference = ((realisticMean - randomMean) / randomMean * 100);

            // Get score distributions
            const randomScores = implementation.maxsimBatchHyperOptimized ? 
                implementation.maxsimBatchHyperOptimized(randomFixtures.query, randomFixtures.documents) :
                implementation.maxsimBatch(randomFixtures.query, randomFixtures.documents);
            const realisticScores = implementation.maxsimBatchHyperOptimized ? 
                implementation.maxsimBatchHyperOptimized(realisticFixtures.query, realisticFixtures.documents) :
                implementation.maxsimBatch(realisticFixtures.query, realisticFixtures.documents);

            const randomAvg = Array.from(randomScores).reduce((sum, s) => sum + s, 0) / randomScores.length;
            const realisticAvg = Array.from(realisticScores).reduce((sum, s) => sum + s, 0) / realisticScores.length;
            const highSimRandom = Array.from(randomScores).filter(s => s > 0.5).length;
            const highSimRealistic = Array.from(realisticScores).filter(s => s > 0.5).length;

            progressEl.classList.remove('active');

            // Display realism comparison results
            let html = `
                <h3>üß¨ Realism Impact Analysis - ${scenario.name}</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h4>‚ö° Performance Impact</h4>
                        <p><strong>Random Embeddings:</strong> ${randomMean.toFixed(2)} ms</p>
                        <p><strong>Realistic Embeddings:</strong> ${realisticMean.toFixed(2)} ms</p>
                        <p><strong>Difference:</strong> <span style="color: ${difference > 0 ? '#d32f2f' : '#388e3c'};">${difference.toFixed(1)}%</span></p>
                        <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                            ${Math.abs(difference) < 5 ? '‚úÖ Negligible performance difference' : 
                              difference > 0 ? '‚ö†Ô∏è Realistic embeddings are slower' : 'üöÄ Realistic embeddings are faster'}
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h4>üìä Score Distributions</h4>
                        <p><strong>Random Avg Score:</strong> ${randomAvg.toFixed(4)}</p>
                        <p><strong>Realistic Avg Score:</strong> ${realisticAvg.toFixed(4)}</p>
                        <p><strong>High Similarity Docs:</strong></p>
                        <p style="margin-left: 20px;">Random: ${highSimRandom}/${scenario.numDocs}</p>
                        <p style="margin-left: 20px;">Realistic: ${highSimRealistic}/${scenario.numDocs}</p>
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h4>üî¨ Analysis</h4>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li><strong>Performance:</strong> ${Math.abs(difference) < 5 ? 
                            'Random and realistic embeddings have nearly identical performance, validating benchmark realism.' :
                            'There is a measurable performance difference, suggesting algorithm sensitivity to data distribution.'}</li>
                        <li><strong>Score Distribution:</strong> ${highSimRealistic > highSimRandom ? 
                            'Realistic embeddings produce more high-similarity matches, better simulating real-world retrieval scenarios.' :
                            'Score distributions are similar, indicating both approaches test the algorithm effectively.'}</li>
                        <li><strong>Benchmark Validity:</strong> ${Math.abs(difference) < 10 ? 
                            'Random embeddings are valid for performance benchmarking.' :
                            'Consider using realistic embeddings for more accurate performance estimates.'}</li>
                    </ul>
                </div>
            `;

            resultsContent.innerHTML = html;
            resultsEl.style.display = 'block';

            log(`‚úÖ Realism test complete!`);
            log(`Performance difference: ${difference.toFixed(1)}%`);
            log(`Random avg score: ${randomAvg.toFixed(4)}, Realistic avg score: ${realisticAvg.toFixed(4)}`);
            
            setStatus('Realism impact test complete!', 'success');

            isRunning = false;
            runBtn.disabled = false;
            runAllBtn.disabled = false;
            realismBtn.disabled = false;
        }

        // Export results
        function exportResults() {
            const data = {
                timestamp: new Date().toISOString(),
                platform: {
                    userAgent: navigator.userAgent,
                    cores: navigator.hardwareConcurrency,
                    memory: navigator.deviceMemory
                },
                results: benchmarkResults
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `maxsim-benchmark-${new Date().toISOString()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            log('üì• Results exported!');
        }

        // Event listeners
        runBtn.addEventListener('click', async () => {
            if (isRunning) return;

            isRunning = true;
            runBtn.disabled = true;
            runAllBtn.disabled = true;
            benchmarkResults = [];

            const scenarioName = document.getElementById('scenario').value;
            const warmup = parseInt(document.getElementById('warmup').value);
            const iterations = parseInt(document.getElementById('iterations').value);

            try {
                const result = await runBenchmark(scenarioName, { warmup, iterations });
                benchmarkResults.push(result);
            } catch (err) {
                setStatus(`Error: ${err.message}`, 'error');
                log(`‚ùå Error: ${err.message}`);
            }

            isRunning = false;
            runBtn.disabled = false;
            runAllBtn.disabled = false;
        });

        runAllBtn.addEventListener('click', async () => {
            if (isRunning) return;
            await runAllBenchmarks();
        });

        exportBtn.addEventListener('click', exportResults);

        realismBtn.addEventListener('click', async () => {
            if (isRunning) return;
            await testRealismImpact();
        });

        // Initialize
        async function init() {
            log('üöÄ MaxSim Benchmark Suite Initialized');

            // Test WASM support and pre-warm if possible
            if (await MaxSimWasm.isSupported()) {
                setStatus('üîÑ Pre-warming WASM+SIMD module...', 'info');
                log('‚úÖ WASM+SIMD supported - initializing...');
                
                // Pre-warm WASM module to avoid first-run failures
                try {
                    const testWasm = new MaxSimWasm();
                    await testWasm.init();
                    setStatus('‚úÖ WASM+SIMD ready! (~4x faster vector operations)', 'success');
                    log('‚úÖ WASM+SIMD pre-warmed and ready');
                } catch (err) {
                    setStatus('‚ö†Ô∏è WASM+SIMD supported but pre-warming failed. Will retry during benchmarks.', 'warning');
                    log(`‚ö†Ô∏è Pre-warming failed: ${err.message}`);
                }
            } else {
                setStatus('‚ö†Ô∏è WASM+SIMD not supported. Using JavaScript only.', 'warning');
                log('‚ö†Ô∏è WASM+SIMD not available (older browser)');
            }

            log('Ready to run benchmarks!');
        }

        init();
    </script>
</body>
</html>
